#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Analyseur de Disposition de Clavier Cr√©ole - Potomitan‚Ñ¢
Analyse les fr√©quences des caract√®res cr√©oles et propose une disposition optimis√©e

Ce programme :
1. Analyse les fr√©quences des caract√®res dans les textes cr√©oles
2. √âtudie la proximit√© des doigts et l'ergonomie de frappe
3. Propose une disposition alternative l√©g√®re √† AZERTY
4. Optimise pour les caract√®res cr√©oles sp√©ciaux (√≤, √©, √®, etc.)

Usage: python DispositionKlavy√©.py
"""

import json
import re
from collections import Counter, defaultdict
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from pathlib import Path

class AnalyseurDisposition:
    
    def __init__(self):
        """Initialise l'analyseur avec les configurations de base"""
        
        # Disposition AZERTY actuelle (3 rang√©es principales)
        self.azerty = {
            'rangee_1': ['a', 'z', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
            'rangee_2': ['q', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm'],
            'rangee_3': ['w', 'x', 'c', 'v', 'b', 'n']
        }
        
        # Positions des doigts (0 = auriculaire gauche, 9 = auriculaire droit)
        self.positions_doigts = {
            # Rang√©e 1 (AZERTYUIOP)
            'a': 0, 'z': 1, 'e': 2, 'r': 3, 't': 4,
            'y': 5, 'u': 6, 'i': 7, 'o': 8, 'p': 9,
            # Rang√©e 2 (QSDFGHJKLM)
            'q': 0, 's': 1, 'd': 2, 'f': 3, 'g': 4,
            'h': 5, 'j': 6, 'k': 7, 'l': 8, 'm': 9,
            # Rang√©e 3 (WXCVBN)
            'w': 0, 'x': 1, 'c': 2, 'v': 3, 'b': 4, 'n': 5
        }
        
        # Force des doigts (index = 1.0, majeur = 0.9, annulaire = 0.7, auriculaire = 0.5)
        self.force_doigts = {
            0: 0.5,  # Auriculaire gauche
            1: 0.7,  # Annulaire gauche
            2: 0.9,  # Majeur gauche
            3: 1.0,  # Index gauche
            4: 1.0,  # Index gauche (T)
            5: 1.0,  # Index droit (Y)
            6: 1.0,  # Index droit
            7: 0.9,  # Majeur droit
            8: 0.7,  # Annulaire droit
            9: 0.5   # Auriculaire droit
        }
        
        # Caract√®res cr√©oles sp√©ciaux
        self.caracteres_creoles = ['√≤', '√©', '√®', '√π', '√†', '√¢', '√™', '√Æ', '√¥', '√ª', '√ß']
        
        # Statistiques
        self.stats_caracteres = Counter()
        self.stats_bigrammes = Counter()
        self.effort_actuel = 0
        self.effort_optimise = 0

    def charger_donnees_creoles(self):
        """Charge les donn√©es cr√©oles depuis les fichiers JSON"""
        print("üìö Chargement des donn√©es cr√©oles...")
        
        # 1. Charger le dictionnaire cr√©ole
        try:
            with open("android_keyboard/app/src/main/assets/creole_dict.json", 'r', encoding='utf-8') as f:
                dict_data = json.load(f)
                print(f"‚úÖ Dictionnaire cr√©ole: {len(dict_data)} mots")
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur dictionnaire: {e}")
            dict_data = []
        
        # 2. Charger les N-grams
        try:
            with open("android_keyboard/app/src/main/assets/creole_ngrams.json", 'r', encoding='utf-8') as f:
                ngrams_data = json.load(f)
                print(f"‚úÖ N-grams cr√©oles: {len(ngrams_data.get('unigrams', {}))} unigrams")
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur N-grams: {e}")
            ngrams_data = {}
        
        return dict_data, ngrams_data

    def analyser_frequences_caracteres(self, dict_data, ngrams_data):
        """Analyse les fr√©quences des caract√®res dans les textes cr√©oles"""
        print("üîç Analyse des fr√©quences des caract√®res...")
        
        # Analyser depuis le dictionnaire
        for mot_freq in dict_data:
            if isinstance(mot_freq, list) and len(mot_freq) == 2:
                mot, freq = mot_freq[0], mot_freq[1]
                for char in mot.lower():
                    if char.isalpha() or char in self.caracteres_creoles:
                        self.stats_caracteres[char] += freq
        
        # Analyser depuis les unigrams
        unigrams = ngrams_data.get('unigrams', {})
        for mot, freq in unigrams.items():
            for char in mot.lower():
                if char.isalpha() or char in self.caracteres_creoles:
                    self.stats_caracteres[char] += freq * 10  # Pond√©ration plus forte
        
        print(f"üìä {len(self.stats_caracteres)} caract√®res analys√©s")
        return self.stats_caracteres

    def analyser_bigrammes_caracteres(self, dict_data, ngrams_data):
        """Analyse les bigrammes de caract√®res pour l'optimisation"""
        print("üîó Analyse des bigrammes de caract√®res...")
        
        # Analyser depuis le dictionnaire
        for mot_freq in dict_data:
            if isinstance(mot_freq, list) and len(mot_freq) == 2:
                mot, freq = mot_freq[0], mot_freq[1]
                mot_clean = mot.lower()
                for i in range(len(mot_clean) - 1):
                    if (mot_clean[i].isalpha() or mot_clean[i] in self.caracteres_creoles) and \
                       (mot_clean[i+1].isalpha() or mot_clean[i+1] in self.caracteres_creoles):
                        bigramme = mot_clean[i] + mot_clean[i+1]
                        self.stats_bigrammes[bigramme] += freq
        
        # Analyser depuis les unigrams (reconstituer les bigrammes probables)
        unigrams = ngrams_data.get('unigrams', {})
        for mot, freq in unigrams.items():
            mot_clean = mot.lower()
            for i in range(len(mot_clean) - 1):
                if (mot_clean[i].isalpha() or mot_clean[i] in self.caracteres_creoles) and \
                   (mot_clean[i+1].isalpha() or mot_clean[i+1] in self.caracteres_creoles):
                    bigramme = mot_clean[i] + mot_clean[i+1]
                    self.stats_bigrammes[bigramme] += freq * 15
        
        print(f"üîó {len(self.stats_bigrammes)} bigrammes analys√©s")
        return self.stats_bigrammes

    def calculer_effort_frappe(self, disposition, texte_test=""):
        """Calcule l'effort de frappe pour une disposition donn√©e"""
        effort_total = 0
        
        if not texte_test:
            # Utiliser les fr√©quences r√©elles des caract√®res
            for char, freq in self.stats_caracteres.items():
                if char in disposition:
                    doigt = disposition[char]
                    force = self.force_doigts.get(doigt, 0.5)
                    effort_total += freq / force
        else:
            # Analyser un texte sp√©cifique
            for char in texte_test.lower():
                if char in disposition:
                    doigt = disposition[char]
                    force = self.force_doigts.get(doigt, 0.5)
                    effort_total += 1 / force
        
        return effort_total

    def calculer_distance_bigrammes(self, disposition):
        """Calcule l'effort des bigrammes (distance entre doigts)"""
        effort_bigrammes = 0
        
        for bigramme, freq in self.stats_bigrammes.items():
            if len(bigramme) == 2 and bigramme[0] in disposition and bigramme[1] in disposition:
                doigt1 = disposition[bigramme[0]]
                doigt2 = disposition[bigramme[1]]
                distance = abs(doigt1 - doigt2)
                
                # P√©nalit√© pour m√™me doigt (frappe rapide difficile)
                if doigt1 == doigt2:
                    penalite = 2.0
                else:
                    penalite = 1.0 + (distance * 0.1)
                
                effort_bigrammes += freq * penalite
        
        return effort_bigrammes

    def generer_disposition_optimisee(self):
        """G√©n√®re une disposition optimis√©e pour le cr√©ole"""
        print("üéØ G√©n√©ration de la disposition optimis√©e...")
        
        # Trier les caract√®res par fr√©quence
        chars_freqs = self.stats_caracteres.most_common()
        
        # Positions optimales (index et majeurs en priorit√©)
        positions_optimales = [3, 6, 2, 7, 4, 5, 1, 8, 0, 9]  # Ordre de pr√©f√©rence des doigts
        
        # Nouvelle disposition
        disposition_optimisee = {}
        
        # Placer les caract√®res cr√©oles sp√©ciaux en positions accessibles
        chars_creoles_dans_texte = [(char, freq) for char, freq in chars_freqs 
                                   if char in self.caracteres_creoles]
        
        # Placer les caract√®res normaux les plus fr√©quents
        chars_normaux = [(char, freq) for char, freq in chars_freqs 
                        if char not in self.caracteres_creoles and char.isalpha()]
        
        print(f"üî§ Caract√®res cr√©oles fr√©quents: {[c[0] for c in chars_creoles_dans_texte[:5]]}")
        print(f"üî§ Caract√®res normaux fr√©quents: {[c[0] for c in chars_normaux[:10]]}")
        
        # Attribution des positions
        position_index = 0
        
        # D'abord les 20 caract√®res les plus fr√©quents (normaux + cr√©oles m√©lang√©s)
        tous_chars = sorted(chars_freqs, key=lambda x: x[1], reverse=True)
        
        for char, freq in tous_chars[:20]:
            if position_index < len(positions_optimales):
                disposition_optimisee[char] = positions_optimales[position_index]
                position_index += 1
        
        return disposition_optimisee

    def comparer_dispositions(self, disp_azerty, disp_optimisee):
        """Compare l'efficacit√© des deux dispositions"""
        print("‚öñÔ∏è Comparaison des dispositions...")
        
        # Cr√©er la disposition AZERTY compl√®te
        azerty_complete = {}
        for char in 'azertyuiopqsdfghjklmwxcvbn':
            if char in self.positions_doigts:
                azerty_complete[char] = self.positions_doigts[char]
        
        # Ajouter les caract√®res cr√©oles en positions arbitraires pour AZERTY
        for char in self.caracteres_creoles:
            if char in self.stats_caracteres:
                azerty_complete[char] = 9  # Position difficile (auriculaire droit)
        
        # Calculer efforts
        effort_azerty = self.calculer_effort_frappe(azerty_complete)
        effort_azerty_bigrammes = self.calculer_distance_bigrammes(azerty_complete)
        
        effort_optimise = self.calculer_effort_frappe(disp_optimisee)
        effort_optimise_bigrammes = self.calculer_distance_bigrammes(disp_optimisee)
        
        # Calculs de performance
        total_azerty = effort_azerty + effort_azerty_bigrammes
        total_optimise = effort_optimise + effort_optimise_bigrammes
        
        amelioration = ((total_azerty - total_optimise) / total_azerty) * 100
        
        print(f"\nüìä R√âSULTATS DE COMPARAISON:")
        print(f"   üî¥ AZERTY Effort Total: {total_azerty:,.0f}")
        print(f"      - Caract√®res: {effort_azerty:,.0f}")
        print(f"      - Bigrammes: {effort_azerty_bigrammes:,.0f}")
        print(f"   üü¢ OPTIMIS√â Effort Total: {total_optimise:,.0f}")
        print(f"      - Caract√®res: {effort_optimise:,.0f}")
        print(f"      - Bigrammes: {effort_optimise_bigrammes:,.0f}")
        print(f"   ‚ú® Am√©lioration: {amelioration:.1f}%")
        
        return {
            'azerty_total': total_azerty,
            'optimise_total': total_optimise,
            'amelioration_pct': amelioration,
            'azerty_chars': effort_azerty,
            'azerty_bigrammes': effort_azerty_bigrammes,
            'optimise_chars': effort_optimise,
            'optimise_bigrammes': effort_optimise_bigrammes
        }

    def afficher_disposition_optimisee(self, disposition):
        """Affiche la disposition optimis√©e sous forme de clavier visuel"""
        print("\n‚å®Ô∏è DISPOSITION OPTIMIS√âE POUR LE CR√âOLE:")
        
        # Cr√©er un mapping inverse (doigt -> caract√®res)
        clavier = {i: [] for i in range(10)}
        for char, doigt in disposition.items():
            clavier[doigt].append(char)
        
        # Afficher sous forme de rang√©es
        print("\n   Rang√©e 1 (AZERTYUIOP):")
        rangee1 = []
        for i in range(10):
            chars = [c for c in clavier[i] if c in 'azertyuiop√†√¢√™√Æ√¥√ª√ß√≤√©√®√π']
            if chars:
                rangee1.append(chars[0])
            else:
                rangee1.append('¬∑')
        print(f"   {' '.join(rangee1)}")
        
        print("\n   Rang√©e 2 (QSDFGHJKLM):")
        rangee2 = []
        for i in range(10):
            chars = [c for c in clavier[i] if c in 'qsdfghjklm']
            if chars:
                rangee2.append(chars[0])
            else:
                rangee2.append('¬∑')
        print(f"   {' '.join(rangee2)}")
        
        # Afficher les caract√®res cr√©oles sp√©ciaux
        print(f"\nüé® Caract√®res cr√©oles optimis√©s:")
        for char in self.caracteres_creoles:
            if char in disposition and char in self.stats_caracteres:
                doigt = disposition[char]
                freq = self.stats_caracteres[char]
                force = self.force_doigts[doigt]
                print(f"   '{char}' ‚Üí doigt {doigt} (force {force}) - {freq} occurrences")

    def generer_rapport_complet(self, stats_comparaison):
        """G√©n√®re un rapport complet de l'analyse"""
        rapport = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                     RAPPORT D'ANALYSE - DISPOSITION CLAVIER CR√âOLE          ‚ïë
‚ïë                              Potomitan‚Ñ¢ - Version 1.0                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä STATISTIQUES G√âN√âRALES:
   ‚Ä¢ Caract√®res analys√©s: {len(self.stats_caracteres)}
   ‚Ä¢ Bigrammes analys√©s: {len(self.stats_bigrammes)}
   ‚Ä¢ Caract√®res cr√©oles d√©tect√©s: {len([c for c in self.stats_caracteres if c in self.caracteres_creoles])}

üî§ TOP 10 CARACT√àRES LES PLUS FR√âQUENTS:
"""
        for i, (char, freq) in enumerate(self.stats_caracteres.most_common(10), 1):
            if char in self.caracteres_creoles:
                rapport += f"   {i:2d}. '{char}' : {freq:,} occurrences ‚≠ê (cr√©ole)\n"
            else:
                rapport += f"   {i:2d}. '{char}' : {freq:,} occurrences\n"

        rapport += f"""
üîó TOP 5 BIGRAMMES LES PLUS FR√âQUENTS:
"""
        for i, (bigramme, freq) in enumerate(self.stats_bigrammes.most_common(5), 1):
            rapport += f"   {i}. '{bigramme}' : {freq:,} occurrences\n"

        rapport += f"""
‚öñÔ∏è COMPARAISON DE PERFORMANCE:
   üî¥ AZERTY (actuel):
      ‚Ä¢ Effort total: {stats_comparaison['azerty_total']:,.0f}
      ‚Ä¢ Effort caract√®res: {stats_comparaison['azerty_chars']:,.0f}
      ‚Ä¢ Effort bigrammes: {stats_comparaison['azerty_bigrammes']:,.0f}
   
   üü¢ DISPOSITION OPTIMIS√âE:
      ‚Ä¢ Effort total: {stats_comparaison['optimise_total']:,.0f}
      ‚Ä¢ Effort caract√®res: {stats_comparaison['optimise_chars']:,.0f}
      ‚Ä¢ Effort bigrammes: {stats_comparaison['optimise_bigrammes']:,.0f}
   
   ‚ú® AM√âLIORATION GLOBALE: {stats_comparaison['amelioration_pct']:.1f}%

üí° RECOMMANDATIONS:
   1. Placer les caract√®res cr√©oles (√≤, √©, √®) sur les touches d'index
   2. Optimiser la position de 'ka', 'an', 't√©' (mots les plus fr√©quents)
   3. R√©duire l'effort des bigrammes courants ('ka', 'an', 'ou')
   4. Int√©grer les accents dans la disposition principale

üéØ CONCLUSION:
   La disposition optimis√©e r√©duit l'effort de frappe de {stats_comparaison['amelioration_pct']:.1f}% 
   par rapport √† AZERTY, sp√©cialement adapt√©e au cr√©ole guadeloup√©en.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
G√©n√©r√© le {pd.Timestamp.now().strftime('%d/%m/%Y √† %H:%M')} | Potomitan‚Ñ¢ Kreyol Keyboard
"""
        return rapport

    def sauvegarder_resultats(self, disposition_optimisee, stats_comparaison):
        """Sauvegarde les r√©sultats dans des fichiers"""
        print("üíæ Sauvegarde des r√©sultats...")
        
        # 1. Disposition optimis√©e (JSON)
        disposition_data = {
            "version": "1.0",
            "type": "keyboard_layout",
            "branding": "Potomitan‚Ñ¢",
            "layout_name": "Creole Optimized",
            "description": "Disposition clavier optimis√©e pour le cr√©ole guadeloup√©en",
            "character_positions": disposition_optimisee,
            "finger_strength": self.force_doigts,
            "stats": stats_comparaison,
            "timestamp": pd.Timestamp.now().isoformat()
        }
        
        with open("disposition_creole_optimisee.json", 'w', encoding='utf-8') as f:
            json.dump(disposition_data, f, ensure_ascii=False, indent=2)
        
        # 2. Rapport complet
        rapport = self.generer_rapport_complet(stats_comparaison)
        with open("rapport_disposition_clavier.txt", 'w', encoding='utf-8') as f:
            f.write(rapport)
        
        # 3. Statistiques CSV pour analyse
        stats_df = pd.DataFrame([
            {'caractere': char, 'frequence': freq, 'type': 'creole' if char in self.caracteres_creoles else 'normal'}
            for char, freq in self.stats_caracteres.most_common()
        ])
        stats_df.to_csv("frequences_caracteres_creoles.csv", index=False, encoding='utf-8')
        
        print("‚úÖ Fichiers sauvegard√©s:")
        print("   ‚Ä¢ disposition_creole_optimisee.json")
        print("   ‚Ä¢ rapport_disposition_clavier.txt")
        print("   ‚Ä¢ frequences_caracteres_creoles.csv")

def main():
    """Fonction principale"""
    print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    print("üá¨üáµ ANALYSEUR DE DISPOSITION CLAVIER CR√âOLE - Potomitan‚Ñ¢")
    print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    # Initialiser l'analyseur
    analyseur = AnalyseurDisposition()
    
    # 1. Charger les donn√©es
    dict_data, ngrams_data = analyseur.charger_donnees_creoles()
    
    if not dict_data and not ngrams_data:
        print("‚ùå Aucune donn√©e trouv√©e ! V√©rifiez les fichiers JSON.")
        return
    
    # 2. Analyser les fr√©quences
    analyseur.analyser_frequences_caracteres(dict_data, ngrams_data)
    analyseur.analyser_bigrammes_caracteres(dict_data, ngrams_data)
    
    # 3. G√©n√©rer la disposition optimis√©e
    disposition_optimisee = analyseur.generer_disposition_optimisee()
    
    # 4. Comparer les dispositions
    stats_comparaison = analyseur.comparer_dispositions(analyseur.azerty, disposition_optimisee)
    
    # 5. Afficher les r√©sultats
    analyseur.afficher_disposition_optimisee(disposition_optimisee)
    
    # 6. Sauvegarder
    analyseur.sauvegarder_resultats(disposition_optimisee, stats_comparaison)
    
    print(f"\nüéâ Analyse termin√©e avec succ√®s !")
    print(f"üìà Am√©lioration de {stats_comparaison['amelioration_pct']:.1f}% par rapport √† AZERTY")
    print(f"üéØ Disposition optimis√©e pour le cr√©ole guadeloup√©en !")

if __name__ == "__main__":
    main()
